/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef audiolib_TYPES_H
#define audiolib_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>


namespace audiolib {

class AudioDataInput;

class SplitResult;

class AudioOutput;

typedef struct _AudioDataInput__isset {
  _AudioDataInput__isset() : dataId(false), content(false), dataType(false), extra(false) {}
  bool dataId :1;
  bool content :1;
  bool dataType :1;
  bool extra :1;
} _AudioDataInput__isset;

class AudioDataInput : public virtual ::apache::thrift::TBase {
 public:

  AudioDataInput(const AudioDataInput&);
  AudioDataInput& operator=(const AudioDataInput&);
  AudioDataInput() : dataId(), content(), dataType(), extra() {
  }

  virtual ~AudioDataInput() throw();
  std::string dataId;
  std::string content;
  std::string dataType;
  std::string extra;

  _AudioDataInput__isset __isset;

  void __set_dataId(const std::string& val);

  void __set_content(const std::string& val);

  void __set_dataType(const std::string& val);

  void __set_extra(const std::string& val);

  bool operator == (const AudioDataInput & rhs) const
  {
    if (!(dataId == rhs.dataId))
      return false;
    if (!(content == rhs.content))
      return false;
    if (!(dataType == rhs.dataType))
      return false;
    if (!(extra == rhs.extra))
      return false;
    return true;
  }
  bool operator != (const AudioDataInput &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AudioDataInput & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AudioDataInput &a, AudioDataInput &b);

std::ostream& operator<<(std::ostream& out, const AudioDataInput& obj);

typedef struct _SplitResult__isset {
  _SplitResult__isset() : succ(false), dataId(false), contents(false), duration(false), segtime(false) {}
  bool succ :1;
  bool dataId :1;
  bool contents :1;
  bool duration :1;
  bool segtime :1;
} _SplitResult__isset;

class SplitResult : public virtual ::apache::thrift::TBase {
 public:

  SplitResult(const SplitResult&);
  SplitResult& operator=(const SplitResult&);
  SplitResult() : succ(0), dataId(), duration(0), segtime(0) {
  }

  virtual ~SplitResult() throw();
  bool succ;
  std::string dataId;
  std::vector<std::string>  contents;
  double duration;
  int32_t segtime;

  _SplitResult__isset __isset;

  void __set_succ(const bool val);

  void __set_dataId(const std::string& val);

  void __set_contents(const std::vector<std::string> & val);

  void __set_duration(const double val);

  void __set_segtime(const int32_t val);

  bool operator == (const SplitResult & rhs) const
  {
    if (!(succ == rhs.succ))
      return false;
    if (!(dataId == rhs.dataId))
      return false;
    if (!(contents == rhs.contents))
      return false;
    if (!(duration == rhs.duration))
      return false;
    if (!(segtime == rhs.segtime))
      return false;
    return true;
  }
  bool operator != (const SplitResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SplitResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SplitResult &a, SplitResult &b);

std::ostream& operator<<(std::ostream& out, const SplitResult& obj);

typedef struct _AudioOutput__isset {
  _AudioOutput__isset() : succ(false), dataId(false), content(false), duration(false), format(false) {}
  bool succ :1;
  bool dataId :1;
  bool content :1;
  bool duration :1;
  bool format :1;
} _AudioOutput__isset;

class AudioOutput : public virtual ::apache::thrift::TBase {
 public:

  AudioOutput(const AudioOutput&);
  AudioOutput& operator=(const AudioOutput&);
  AudioOutput() : succ(0), dataId(), content(), duration(0), format() {
  }

  virtual ~AudioOutput() throw();
  bool succ;
  std::string dataId;
  std::string content;
  double duration;
  std::string format;

  _AudioOutput__isset __isset;

  void __set_succ(const bool val);

  void __set_dataId(const std::string& val);

  void __set_content(const std::string& val);

  void __set_duration(const double val);

  void __set_format(const std::string& val);

  bool operator == (const AudioOutput & rhs) const
  {
    if (!(succ == rhs.succ))
      return false;
    if (!(dataId == rhs.dataId))
      return false;
    if (!(content == rhs.content))
      return false;
    if (!(duration == rhs.duration))
      return false;
    if (!(format == rhs.format))
      return false;
    return true;
  }
  bool operator != (const AudioOutput &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AudioOutput & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AudioOutput &a, AudioOutput &b);

std::ostream& operator<<(std::ostream& out, const AudioOutput& obj);

} // namespace

#endif
